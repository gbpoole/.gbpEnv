" Vim config file for gbp

" Avoid modeline vulnerability {{{
set nomodeline

" Set-up secure modeline as per: https://blog.firosolutions.com/exploits/vimsploit/
let g:secure_modelines_verbose = 0
let g:secure_modelines_modelines = 15
" }}}

" Initialization {{{
"
" The following is mostly taken from Damian Conway's vimrc:
"   https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup/blob/master/.vimrca
"
" with some help from that of Simon Mutch:
"   https://github.com/smutch/vim-config 

" Change leader mapping {{{
let mapleader = '_'
" }}}

" Terminal colours & encoding {{{

" Set colour usage
set t_Co=256
if exists('&termguicolors')
    set termguicolors
endif

" Encoding
setglobal termencoding=utf-8 fileencodings=
scriptencoding utf-8
set encoding=utf-8

autocmd BufNewFile,BufRead  *   try
autocmd BufNewFile,BufRead  *       set encoding=utf-8
autocmd BufNewFile,BufRead  *   endtry

" Needed for Gnu Screen
if (match($TERM, "screen")!=-1) && !exists('&termguicolors')
    set term=screen-256color
endif
" }}}

" Query system name and OS type {{{
let os = substitute(system('uname'), "\n", "", "")
let hostname = substitute(system('hostname'), '\n', '', '')
" }}}

" Determine file type {{{
filetype plugin indent on

augroup FiletypeInference
    autocmd!
    autocmd BufNewFile,BufRead  *.t      setfiletype perl
    autocmd BufNewFile,BufRead  *.pod    setfiletype pod
    autocmd BufNewFile,BufRead  *.itn    setfiletype itn
    autocmd BufNewFile,BufRead  *        call s:infer_filetype()
augroup END

function! s:infer_filetype ()
    for line in getline(1,20)
        if line =~ '^\s*use\s*v\?5\.\S\+\s*;\s*$'
            setfiletype perl
            return
        elseif line =~ '^\s*use\s*v\?6\s*;\s*$'
            setfiletype perl6
            return
        endif
    endfor
endfunction
" }}}

" Enable marker folding for vimrc {{{
" (secure modeline takes care of other cases)
set foldmethod=marker
" }}}

" Enable Nmap command for documented mappings {{{
runtime plugin/documap.vim
" }}}

" Ensure autodoc'd plugins are supported {{{
runtime plugin/_autodoc.vim
" }}}

" Edit and auto-update this config file and plugins {{{
augroup VimReload
autocmd!
    autocmd BufWritePost $MYVIMRC source $MYVIMRC
augroup END
Nmap <silent> <leader>ve [Edit .vimrc] :next $MYVIMRC<CR>
Nmap <silent> <leader>vr [Edit .vimrc] :source $MYVIMRC<CR>
" }}}

" Prefer vertical orientation when using :diffsplit {{{
set diffopt+=vertical
" }}}

" Use persistent undo {{{
if has('persistent_undo')
    set undodir=$HOME/.VIM_UNDO_FILES " Save all undo files in a single location (less messy, more risky)...
    set undolevels=5000               " Save a lot of back-history...
    set undofile                      " Actually switch on persistent undo
endif
" }}}

" Goto last location in non-empty files {{{
autocmd BufReadPost *  if line("'\"") > 1 && line("'\"") <= line("$")
                   \|     exe "normal! g`\""
                   \|  endif
" }}}

" Set up smarter search behaviour {{{
set incsearch       "Lookahead as search pattern is specified
"set ignorecase      "Ignore case in all searches...
"set smartcase       "...unless uppercase letters used

" Absolute direction for n and N...
nnoremap  <silent><expr> n  'Nn'[v:searchforward] . ":call HLNext()\<CR>"
nnoremap  <silent><expr> N  'nN'[v:searchforward] . ":call HLNext()\<CR>"

"Delete in normal mode to switch off highlighting till next search and clear messages...
Nmap <silent> <BS> [Cancel highlighting]  :call HLNextOff() <BAR> :nohlsearch <BAR> :call VG_Show_CursorColumn('off')<CR>::HierClear<CR>               

"Double-delete to remove trailing whitespace...
Nmap <silent> <BS><BS>  [Remove trailing whitespace] mz:call TrimTrailingWS()<CR>`z                  

function! TrimTrailingWS ()
    if search('\s\+$', 'cnw')
        :%s/\s\+$//g
    endif
endfunction

" Improved search mapping to replace :%s/.../.../g {{{
Nmap S  [Shortcut for :s///g]  :%s//g<LEFT><LEFT>
xmap S                         :s//g<LEFT><LEFT>

Nmap <expr> M  [Shortcut for :s/<last match>//g]  ':%s/' . @/ . '//g<LEFT><LEFT>'
xmap <expr> M                                     ':s/' . @/ . '//g<LEFT><LEFT>'
" }}}

" }}}

" smartwrapping {{{

" No smartwrapping in any of these files...
"let g:SW_IGNORE_FILES = '.vimrc,*.vim,*.pl,*.pm,**/bin/**'

" set comments-=s1:/*,mb:*,ex:*/      "Don't recognize C comments
" set comments-=:XCOMM                "Don't recognize lmake comments
" set comments-=:%                    "Don't recognize PostScript comments
" set comments-=:#                    "Don't recognize Perl/shell comments
" set comments+=fb:*                  "Star-space is a bullet
" set comments+=fb:-                  "Dash-space is a bullets
set formatoptions-=cro
set formatoptions+=j                  " Remove comment introducers when joining comment lines
set wrapmargin=2                      "Wrap 2 characters from the edge of the window
"set cinwords = ""                    "But not for C-like keywords
set cinoptions+=#1
set cinkeys-=0#
" }}}

" smartindent {{{
set autoindent                        "Retain indentation on next line
set smartindent                       "Turn on autoindenting of blocks
let g:vim_indent_cont = 0             " No magic shifts on Vim line continuations

"And no shift magic on comments...
nmap <silent>  >>  <Plug>ShiftLine
nnoremap <Plug>ShiftLine :call ShiftLine()<CR>
function! ShiftLine() range
    set nosmartindent
    exec "normal! " . v:count . ">>"
    set smartindent
    silent! call repeat#set( "\<Plug>ShiftLine" )
endfunction
" }}}

" Make Visual modes work better {{{
"" Visual Block mode is far more useful that Visual mode (so swap the commands)...
"nnoremap v <C-V>
"xnoremap v <C-V>
"nnoremap <C-V> v
"xnoremap <C-V> v

""Square up visual selections...
"set virtualedit=block

"" Make BS/DEL work as expected in visual modes (i.e. delete the selected text)...
"xmap <BS> x

"" Make vaa select the entire file...
"xmap aa VGo1G

" Make q extend to the surrounding string...
"xmap  q   "_y:call ExtendVisualString()<CR>
"
"let s:closematch = [ '', '', '}', ']', ')', '>', '/', "'", '"', '`' ]
"let s:ldelim = '\< \%(q [qwrx]\= \| [smy] \| tr \) \s*
"\               \%(
"\                   \({\) \| \(\[\) \| \((\) \| \(<\) \| \(/\)
"\               \)
"\               \|
"\                   \(''\) \| \("\) \| \(`\)
"\'
"let s:ldelim = substitute(s:ldelim, '\s\+', '', 'g')

"function! ExtendVisualString ()
"    let [lline, lcol, lmatch] = searchpos(s:ldelim, 'bWp')
"    if lline == 0
"        return
"    endif
"    let rdelim = s:closematch[lmatch]
"    normal `>
"    let rmatch = searchpos(rdelim, 'W')
"    normal! v
"    call cursor(lline, lcol)
"endfunction
" }}}

" Make arrow keys move visual blocks around {{{
"
"xmap <up>    <Plug>SchleppUp
"xmap <down>  <Plug>SchleppDown
"xmap <left>  <Plug>SchleppLeft
"xmap <right> <Plug>SchleppRight
"
"xmap D       <Plug>SchleppDupLeft
"xmap <C-D>   <Plug>SchleppDupLeft
" }}}

" Enable window switching with <leader>-<#> {{{
let i = 1
while i <= 9
    execute 'nnoremap <Leader>' . i . ' :' . i . 'wincmd w<CR>'
    let i = i + 1
endwhile
function! WindowNumber()
    let str=tabpagewinnr(tabpagenr())
    return str
endfunction
function! s:CMake()
    let src_dir = fnamemodify(findfile('CMakeLists.txt', '.;'), ':p:h')
    let build_dir = finddir('build', '.;')

    if build_dir =~ ""
        let build_dir = src_dir . '/build'
        echo build_dir
        call system('mkdir -p ' . build_dir)
    endif
    let &makeprg = 'make -j2 -C ' . build_dir

    exec 'Dispatch -dir=' . build_dir . ' cmake .. ' . g:cmake_opts
endfunction
command! CMake call <SID>CMake()
" }}}

" Miscellaneous features (mainly options) {{{
set title           "Show filename in titlebar of window
set titleold=
"set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
set title titlestring=

set nomore          "Don't page long listings

set cpoptions-=a    "Don't set # after a :read

set autowrite       "Save buffer automatically when changing files
set autoread        "Always reload buffer when external changes detected
"           +--Disable hlsearch while loading viminfo
"           | +--Remember marks for last 500 files
"           | |    +--Remember up to 10000 lines in each register
"           | |    |      +--Remember up to 1MB in each register
"           | |    |      |     +--Remember last 1000 search patterns
"           | |    |      |     |     +---Remember last 1000 commands
"           | |    |      |     |     |
"           v v    v      v     v     v
set viminfo=h,'500,<10000,s1000,/1000,:1000
set backspace=indent,eol,start      "BS past autoindents, line boundaries,
                                    "     and even the start of insertion
set fileformats=unix,mac,dos        "Handle Mac and DOS line-endings
                                    "but prefer Unix endings
"set wildignorecase                  "Case-insensitive completions
set wildmode=list:longest,full      "Show list of completions
                                    "  and complete as much as possible,
                                    "  then iterate full completions
"set complete-=t                     " I don't use tags, so no need to search for them
set infercase                       "Adjust completions to match case
set noshowmode                      "Suppress mode change messages
"set updatecount=50                  "Save buffer every X chars typed
set timeout timeoutlen=300 ttimeoutlen=300  " Keycodes and maps timeout in 3/10 sec...
set updatetime=2000                         "idleness" is 2 sec
set scrolloff=2                             "Scroll when 3 lines from top/bottom

"Turn on wildmenu:
"   First tab: longest match, list in the statusbar.
"   Following tabs: cycle through matches
set wildmenu wildmode=longest:full,full

set vb t_vb=                         " Turn off visual beep
set laststatus=2                     " Always display a status line
set cmdheight=1                      " Command line height
set listchars=tab:▸\ ,trail:·        " Set hidden characters
set number                           " Show line numbers
set hlsearch                         " Highlight searches
set history=500                      " Store a ton of history (default is 20)
set wildmenu                         " show list instead of just completing
set autoread                         " Automatically re-read changed files
set hidden                           " Don't unload a buffer when abandoning it
set clipboard=unnamed                " To work in tmux
set spelllang=en_au                  " Australian spelling
set secure                           " Secure mode for reading vimrc, exrc files etc. in current dir
set exrc                             " Allow the use of folder dependent settings
set backspace=indent,eol,start       " Sane backspace
set autoindent                       " Autoindent
set nosmartindent                    " Turning this off as messes with python comment indents.
set wrap                             " Wrap lines
set linebreak                        " Wrap at breaks
set textwidth=0 wrapmargin=0
set display=lastline
set formatoptions+=l                 " Dont mess with the wrapping of existing lines
set expandtab tabstop=4 shiftwidth=4 " 4 spaces for tabs
set incsearch                        " Highlight matches as you type
set hlsearch                         " Highlight matches
set showmatch                        " Show matching paren
set ignorecase                       " case insensitive search
set smartcase                        " case sensitive when uc present
set gdefault                         " g flag on sed subs automatically
set backupdir=~/.vim_backup
set directory=~/.vim_backup
set undodir=~/.vim/.vim_backup/undo  " where to save undo histories
set undofile                         " Save undo's after file closes
set vb t_vb=                         " Turn off visual beep
set laststatus=2                     " Always display a status line
set cmdheight=1                      " Command line height
set listchars=tab:▸\ ,eol:↵,trail:·  " Set hidden characters
set number                           " Show line numbers
" set cursorline                       " highlight current line
set mouse=a      " enable mouse for all modes settings.  Also avoids copying line numbers:
                 " https://stackoverflow.com/questions/5728259/how-to-clear-the-line-number-in-vim-when-copying
"set shellcmdflag=-ic      " Use an interactive shell to allow use of command line aliases
"let g:c_syntax_for_h = 1  " Use c-syntax

set wildignore+=*.o,*.obj,*.pyc,
            \*.aux,*.blg,*.fls,*.blg,*.fdb_latexmk,*.latexmain,.DS_Store,
            \Session.vim,Project.vim,tags,.tags,.sconsign.dblite,.ccls-cache

" Set suffixes that are ignored with multiple match
set suffixes=.bak,~,.o,.info,.swp,.obj

if has("nvim") && exists("+pumblend")
    set pumblend=20  " opacity for popupmenu
endif

if exists('&inccommand')
  set inccommand=nosplit " Live substitution
endif
" }}}

" Use ripgrep if possible {{{
"    ... if not then ack, and fall back to grep if all else fails
if executable('rg')
    set grepprg=set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case\ --trim
elseif executable('ack')
    set grepprg=ack\ -s\ -H\ --nocolor\ --nogroup\ --column
    set grepformat=%f:%l:%c:%m,%f:%l:%m
else
    " Grep will sometimes skip displaying the file name if you
    " search in a singe file. Set grep
    " program to always generate a file-name.
    set grepprg=grep\ -nHRI\ $*\ .
endif
nnoremap <leader>* :silent grep! "<C-r><C-w>"<CR>:copen<CR>:redraw!<CR>
command! -nargs=+ -complete=file -bar Grep silent grep! <args>|copen|redraw!
nnoremap <leader>/ :Grep
" }}}

"" Back up the current file
"Nmap BB [Back up current file]  :!bak -q %<CR><CR>:echomsg "Backed up" expand('%')<CR>
" }}}

" System and OS dependencies {{{
if os == "Darwin"
    let Tlist_Ctags_Cmd="/usr/local/bin/ctags"
    let cscope_cmd="/usr/local/bin/cscope"
    "let g:python3_host_prog = '/usr/local/Caskroom/miniconda/base/envs/nvim/bin/python'
    "let g:cmake_opts = '-DHDF5_ROOT=/usr/local -DMPI_C_COMPILER=/usr/local/bin/mpicc'
else
    let g:cmake_opts = ''
    let cscope_cmd="/usr/bin/cscope"
end
" }}}

" Set plugins {{{

" Install vim-plug automatically if absent
if has('win32') && empty(glob('~/vimfiles/autoload/plug.vim'))
    echohl Error
    echo "\nVim-plug has not been installed.  Download via:\n    git clone https://github.com/junegunn/vim-plug ~/.vim/autoload\nand install packages by running :PlugInstall from within vim.\
n"
    echohl None
    finish
elseif !has('win32') && empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin()

    " Healthy defaults
    Plug 'tpope/vim-sensible'

    " Aesthetics
    Plug 'vim-airline/vim-airline'
    Plug 'vim-airline/vim-airline-themes'

    " Add Molokai colorscheme.  Needs to be chosen later.
    Plug 'tomasr/molokai'

    " Add support for editorconfig files (see http://editorconfig.org/ &
    " https://github.com/editorconfig/editorconfig-vim)
    Plug 'editorconfig/editorconfig-vim'

    " Make terminal vim and tmux work better together"
    " https://github.com/tmux-plugins/vim-tmux-focus-events"
    Plug 'tmux-plugins/vim-tmux-focus-events'

    " Motion
    Plug 'tpope/vim-rsi'
    Plug 'justinmk/vim-sneak'
    Plug 'tpope/vim-surround'

    " Snipits
    Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'

    " Editing
    Plug 'jiangmiao/auto-pairs'
    Plug 'scrooloose/nerdcommenter'

    " IDE-like things
    Plug 'chrisbra/vim-diff-enhanced'
    Plug 'tpope/vim-vinegar'
    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } | Plug 'junegunn/fzf.vim'
    Plug 'majutsushi/tagbar'
    Plug 'airblade/vim-gitgutter'
    Plug 'rhysd/git-messenger.vim'

    " Tags
    Plug 'ludovicchabant/vim-gutentags'

    " Linting
    Plug 'w0rp/ale'

    " Zen-mode
    Plug 'reedes/vim-wordy', { 'for': ['markdown', 'tex', 'latex'] }
    Plug 'davidbeckingsale/writegood.vim', { 'for': ['tex', 'markdown', 'latex'] }
    Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }

    " File-sepcific stuff
    Plug 'sheerun/vim-polyglot'
    Plug 'Glench/Vim-Jinja2-Syntax', { 'for': 'html' }
    Plug 'vim-python/python-syntax', { 'for': 'python' }
    Plug 'Vimjas/vim-python-pep8-indent', { 'for': 'python'}
    Plug 'davidhalter/jedi-vim', { 'for': 'python' }
    Plug 'tmhedberg/SimpylFold', { 'for': 'python' }

    " Completion
    Plug 'ncm2/ncm2'
    Plug 'roxma/nvim-yarp'  " ncm2 requires nvim-yarp
    Plug 'ncm2/float-preview.nvim'

    " some completion sources
    Plug 'ncm2/ncm2-bufword'
    augroup plug_ncm2
        autocmd FileType * if expand('<amatch>') != 'tex' | call plug#load('ncm2/ncm2-bufword') | execute 'autocmd! plug_ncm2' | endif
    augroup END
    Plug 'ncm2/ncm2-tmux'
    Plug 'ncm2/ncm2-path'
    Plug 'ncm2/ncm2-jedi'
    Plug 'ncm2/ncm2-ultisnips'
    Plug 'ncm2/ncm2-pyclang'
    Plug 'ncm2/ncm2-tagprefix'
    Plug 'ncm2/ncm2-github'

    "Plug 'autozimu/LanguageClient-neovim', {
    "    \ 'branch': 'next',
    "    \ 'do': 'bash install.sh',
    "    \ }
call plug#end()
" }}}

" Aesthetics {{{
" Set color scheme(s)
try
    colorscheme molokai
    let g:airline_theme='molokai'
catch /^Vim\%((\a\+)\)\=:E185/
    echom "Colourscheme not found.  Perhaps plugins have not been installed?  Try running :PlugInstall"
endtry

" Needed to make sure that tmux pane highlighting works
autocmd ColorScheme * highlight Normal ctermbg=None
autocmd ColorScheme * highlight NonText ctermbg=None

" Comments
highlight Comment term=bold cterm=italic ctermfg=white gui=italic guifg=white

"" Make naughty characters visible...
"" (uBB is right double angle, uB7 is middle dot)
"set lcs=tab:»·,trail:␣,nbsp:˷
"highlight InvisibleSpaces ctermfg=Black ctermbg=Black
"call matchadd('InvisibleSpaces', '\S\@<=\s\+\%#\ze\s*$')
"
"augroup VisibleNaughtiness
"    autocmd!
"    autocmd BufEnter  *       set list
"    autocmd BufEnter  *       set list
"    autocmd BufEnter  *.txt   set nolist
"    autocmd BufEnter  *.vp*   set nolist
"    autocmd BufEnter  *       if !&modifiable
"    autocmd BufEnter  *           set nolist
"    autocmd BufEnter  *       endif
"augroup END

" Highlighting
set hlsearch        "Highlight all matches
"highlight clear Search
"highlight       Search    ctermfg=White  ctermbg=Black  cterm=bold
"highlight    IncSearch    ctermfg=White  ctermbg=Red    cterm=bold

" Set background
set background=dark

" Cursor configuration 
if has("nvim")
    " set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor
else
    let &t_SI = "\<Esc>[5 q"
    if exists("&t_SR")
        let &t_SR = "\<Esc>[3 q"
    endif
    let &t_EI = "\<Esc>[2 q"
endif

"" Set a hotkey for toggling paste mode
"nnoremap <F2> :set invpaste paste?<CR>
"set pastetoggle=<F2>
"set showmode

" }}}

" cscope {{{
if has("cscope")
    let &csprg = cscope_cmd
    set csto=0
    " set cst
    set nocsverb
    " add any database in current directory
    if filereadable("cscope.out")
        cs add cscope.out
    " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
    set csverb

    " put the cscope output in the quickfix window
    set cscopequickfix=s-,c-,d-,i-,t-,e-

    " map g<C-]> :cs find 3 <C-R>=expand("<cword>")<CR><CR>
    " map g<C-\> :cs find 0 <C-R>=expand("<cword>")<CR><CR>
    " map g<C-/> :cs find s <C-R>=expand("<cword>")<CR><CR>
endif
" }}}

" Properly switch colors {{{
"" Taken from: https://github.com/altercation/solarized/issues/102#issuecomment-275269574
"
"if !exists('s:known_links')
"  let s:known_links = {}
"endif
"
"function! s:Find_links()
"  " Find and remember links between highlighting groups.
"  redir => listing
"  try
"    silent highlight
"  finally
"    redir END
"  endtry
"  for line in split(listing, "\n")
"    let tokens = split(line)
"    " We're looking for lines like "String xxx links to Constant" in the
"    " output of the :highlight command.
"    if len(tokens) == 5 && tokens[1] == 'xxx' && tokens[2] == 'links' && tokens[3] == 'to'
"      let fromgroup = tokens[0]
"      let togroup = tokens[4]
"      let s:known_links[fromgroup] = togroup
"    endif
"  endfor
"endfunction
"function! s:Restore_links()
"  " Restore broken links between highlighting groups.
"  redir => listing
"  try
"    silent highlight
"  finally
"    redir END
"  endtry
"  let num_restored = 0
"  for line in split(listing, "\n")
"    let tokens = split(line)
"    " We're looking for lines like "String xxx cleared" in the
"    " output of the :highlight command.
"    if len(tokens) == 3 && tokens[1] == 'xxx' && tokens[2] == 'cleared'
"      let fromgroup = tokens[0]
"      let togroup = get(s:known_links, fromgroup, '')
"      if !empty(togroup)
"        execute 'hi link' fromgroup togroup
"        let num_restored += 1
"      endif
"    endif
"  endfor
"endfunction
" }}}

" Tags stuff {{{
set tags+=./tags;$HOME   " recursively search up dir stack for tags file
function! GenCtags()
    let s:cmd = ' -R --fields=+iaS --extra=+q'
    if exists("g:Tlist_Ctags_Cmd")
        execute ':!'.g:Tlist_Ctags_Cmd.s:cmd
    else
        execute ':! ctags'.s:cmd
    endif
endfun
" }}}

" Plugin Settings {{{

" ALE {{{
let g:ale_lint_on_text_changed = 'normal'
let g:ale_linters = {
\   'python': ['flake8'],
\   'c' : ['clangtidy', 'cppcheck', 'clang'],
\   'cpp' : ['clangtidy', 'cppcheck'],
\   'cuda': ['cppcheck']
\}
" \   'c' : ['cppcheck', 'ccls', 'clangtidy'],
" \   'cpp' : ['cppcheck', 'ccls'],

let g:ale_fixers = {
\   'c': ['clang-format']
\}
if (hostname =~ "farnarkle") || (hostname =~ "swin.edu.au")
    let g:ale_cpp_cppcheck_executable="/fred/oz013/smutch/3rd_party/cppcheck/bin/cppcheck"
    let g:ale_c_cppcheck_executable=g:ale_cpp_cppcheck_executable
    let g:ale_cuda_cppcheck_executable=g:ale_cpp_cppcheck_executable
    " let g:ale_cpp_clang_executable="/home/smutch/.conda/envs/gpu_test/bin/clang++"
    " let g:ale_c_clang_executable="/home/smutch/.conda/envs/gpu_test/bin/clang"
    let g:ale_c_ccls_executable="/home/smutch/freddos/meraxes/3rd_party/ccls/bin/ccls"
    " call remove(g:ale_linters['c'], 1, 2)
endif

let g:ale_c_build_dir_names=['build', 'cmake-build-debug']
" let g:ale_cpp_cppcheck_options="--project=compile_commands.json --enable=style"
let g:ale_c_clangtidy_checks = ['-*', 'google-*', '-google-runtime-references', '-google-readability-braces-around-statements', 'modernize-*', 'mpi-*', 'performance-*', 'clang-analyzer-*', 'bugprone-*']
let g:ale_cpp_clangtidy_checks = g:ale_c_clangtidy_checks + ['cppcoreguidelines-*', '-cppcoreguidelines-pro-*']
let g:ale_c_clangformat_options = "-style=WebKit"
let g:ale_python_flake8_options = "--ignore=E501,E402,E226,E203,W503"
let g:ale_tex_chktex_options = "-I -n 35"
let g:ale_sign_error = '✖'
let g:ale_sign_warning = '!'
let g:ale_sign_info = 'ℹ'
let g:ale_sign_style_error = 'S>'
let g:ale_sign_style_warning = 's>'

hi! ALEError cterm=underline gui=underline guisp=Red
hi! link ALEWarning WarningMsg
hi! link ALEInfo MoreMsg
let g:ale_virtualtext_cursor = 1
let g:ale_virtualtext_prefix = '» '

nmap <leader>ar <Plug>(ale_find_references)
nmap <leader>af <Plug>(ale_fix)
nmap <leader>ad <Plug>(ale_go_to_definition)
nmap <leader>aD <Plug>(ale_go_to_definition_in_split)
nmap <leader>at <Plug>(ale_go_to_type_definition)
nmap <leader>aT <Plug>(ale_go_to_type_definition_in_split)
nmap <leader>ak <Plug>(ale_hover)
nmap <leader>al <Plug>(ale_lint)
" Map movement through errors without wrapping.
nmap <silent> <leader>a[ <Plug>(ale_previous)
nmap <silent> <leader>a] <Plug>(ale_next)

" OR map keys to use wrapping.
nmap <silent> <leader>a{ <Plug>(ale_previous_wrap)
nmap <silent> <leader>a} <Plug>(ale_next_wrap)
" }}}

" airline {{{
let g:airline#extensions#tmuxline#enabled = 0
let g:airline#extensions#tabline#enabled = 0
let g:airline_powerline_fonts = 1
let g:airline_left_sep=''
let g:airline_right_sep=''

call airline#parts#define_function('winnum', 'WindowNumber')
function! MyPlugin(...)
    let s:my_part = airline#section#create(['winnum'])
    " let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x) . g:airline_right_sep . ' [' . s:my_part . ']'
    let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x) . ' [' . s:my_part . ']'
endfunction
silent call airline#add_statusline_func('MyPlugin')
" }}}

" float-preview {{{
let g:float_preview#docked = 0
" }}}

" fzf {{{
" Advanced customization using autoload functions
inoremap <expr> <c-x><c-k> fzf#vim#complete#word({'left': '15%'})

" This is the default extra key bindings
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-o': 'split',
  \ 'ctrl-v': 'vsplit' }

" Default fzf layout
" - down / up / left / right
" - window (nvim only)
let g:fzf_layout = { 'up': '~40%' }

" Customize fzf colors to match your color scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" For Commits and BCommits to customize the options used by 'git log':
let g:fzf_commits_log_options = '--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"'

" Mappings and commands
nmap <leader>fm <plug>(fzf-maps-n)
xmap <leader>fm <plug>(fzf-maps-x)
omap <leader>fm <plug>(fzf-maps-o)

" redefine some commands to use the preview feature
" command! -bang -nargs=* -complete=file Files call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
" command! -bang -nargs=* -complete=dir Ag call fzf#vim#ag(<q-args>, fzf#vim#with_preview(), <bang>0)
" command! -bang History call fzf#vim#history(fzf#vim#with_preview(), <bang>0)

command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

nnoremap <leader>fb :Buffers<CR>
nnoremap <leader>ff :Files %:p:h<CR>
nnoremap <leader>fhf :History<CR>
nnoremap <leader>fh: :History:<CR>
nnoremap <leader>fh/ :History/<CR>
nnoremap <leader>f: :Commands<CR>
nnoremap <leader>fw :Windows<CR>
nnoremap <leader>fs :Snippets<CR>
nnoremap <leader>f? :Helptags<CR>
nnoremap <leader>fg :GitFiles?<CR>
nnoremap <leader>fl :Lines<CR>
nnoremap <leader>fL :BLines<CR>
nnoremap <leader>ft :Tags<CR>
nnoremap <leader>fT :BTags<CR>
nnoremap <leader>f/ :Rg<CR>

imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
" project files
function! s:find_git_root()
  return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
endfunction
" command! -bang FZFProjectFiles call fzf#vim#files(s:find_git_root(), fzf#vim#with_preview(), <bang>0)
command! -bang FZFProjectFiles call fzf#vim#files(s:find_git_root(), <bang>0)
nnoremap <leader>fp :FZFProjectFiles<CR>
" }}}

" gitgutter {{{
let g:gitgutter_map_keys = 0
autocmd BufNewFile,BufRead /Volumes/* let g:gitgutter_enabled = 0
nnoremap ]h :GitGutterNextHunk<CR>
nnoremap [h :GitGutterPrevHunk<CR>
nnoremap ghs :GitGutterStageHunk<CR>
nnoremap ghr :GitGutterRevertHunk<CR>
nnoremap ghp :GitGutterPreviewHunk<CR>
let g:gitgutter_realtime = 0
let g:gitgutter_sign_added = '┃'
let g:gitgutter_sign_modified = '┃'
let g:gitgutter_sign_removed = '┃'
let g:gitgutter_sign_modified_removed = '┃'
" }}}

" goyo {{{
let g:goyo_width = 82
" }}}

" {{{ gutentags
let g:gutentags_resolve_symlinks = 0
let g:gutentags_project_root = [".git",".project.json"]
let g:gutentags_ctags_tagfile = ".tags"
let g:gutentags_enabled = 1
let g:gutentags_ctags_extra_args = ['--c++-kinds=+p', '--c-kinds=-p', '--fields=+iaS', '--extra=+q']
let g:gutentags_ctags_exclude = ['build']
" }}}

" jedi {{{

" ---
" UNCOMMENT TO DISABLE
" let g:jedi#auto_initialization = 0
" ---

" These two are required for neocomplete
" let g:jedi#completions_enabled = 0
" let g:jedi#auto_vim_configuration = 0

" Ensure conda paths are being used (see https://github.com/cjrh/vim-conda/issues/15)
" let s:custom_sys_paths = system('~/miniconda3/bin/python -c "import sys; print(sys.path)"')
" py3 << EOF
" import vim, sys, ast
" sys.path.extend(ast.literal_eval(vim.eval("s:custom_sys_paths")))
" EOF

let g:jedi#force_py_version = 3
let g:jedi#popup_on_dot = 0
let g:jedi#show_call_signatures = 2  "May be too slow...
let g:jedi#auto_close_doc = 0
autocmd FileType python let b:did_ftplugin = 1
let g:jedi#goto_stubs_command = '<localleader>s'
let g:jedi#goto_assignments_command = '<localleader>g'
let g:jedi#goto_command = '<localleader>d'
let g:jedi#rename_command = '<localleader>r'
let g:jedi#usages_command = '<localleader>u'

" move documentation to the right if the window is big enough
" au BufAdd * if bufname(expand('<afile>')) ==# "'__doc__'" | silent! wincmd L | endif

" close the documentation window
autocmd FileType python nnoremap <buffer> <localleader>D :exec bufwinnr('__doc__') . "wincmd c"<CR>
" }}}

" matchit {{{
" Match angle brackets...
set matchpairs+=<:>,«:»,｢:｣
if !exists('g:loaded_matchit')
  runtime macros/matchit.vim
endif
" }}}

" ncm2 {{{
" " enable for all buffers except terminals
augroup ncm2
    autocmd BufEnter * if &buftype !=# 'terminal' | call ncm2#enable_for_buffer()
augroup end

" note that must keep noinsert in completeopt, the others is optional
set completeopt=noinsert,menuone,noselect

" supress the annoying 'match x of y', 'The only match' and 'Pattern not
" found' messages
set shortmess+=c

" CTRL-C doesn't trigger the InsertLeave autocmd . map to <ESC> instead.
inoremap <c-c> <ESC>

" When the <Enter> key is pressed while the popup menu is visible, it only
" hides the menu. Use this mapping to close the menu and also start a new
" line.
inoremap <expr> <CR> (pumvisible() ? "\<c-y>\<cr>" : "\<CR>")

" Use <TAB> to select the popup menu:
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" if we are using manual completion
inoremap <silent> <c-space> <c-r>=ncm2#manual_trigger()<cr>
" }}}

" ncm2-pyclang {{{
if (hostname =~ "farnarkle") || (hostname =~ "swin.edu.au")
    let g:ncm2_pyclang#library_path = "/apps/skylake/software/compiler/gcc/6.4.0/clang/5.0.1/lib/libclang.so.5.0"
else
    let g:ncm2_pyclang#library_path = "/usr/local/opt/llvm/lib"
endif

autocmd FileType c,cpp nnoremap <buffer> gd :<C-u>call ncm2_pyclang#goto_declaration()<CR>

" show the preview window
" let g:cm_completeopt="menu,menuone,noinsert,noselect,preview"
" automatically close the preview window after completion
" au CompleteDone * pclose
" }}}

" nerd_commenter {{{
let g:NERDCustomDelimiters = {
            \ 'scons': { 'left': '#' },
            \ 'jinja': { 'left': '<!--', 'right': '-->' },
            \ }
let g:NERDSpaceDelims = 1
let g:NERDAltDelims_c = 1
map <leader><leader> <plug>NERDCommenterToggle
nnoremap <leader>cp yy:<C-u>call NERDComment('n', 'comment')<CR>p
nnoremap <leader>cP yy:<C-u>call NERDComment('n', 'comment')<CR>P
vnoremap <leader>cp ygv:<C-u>call NERDComment('x', 'comment')<CR>`>p
vnoremap <leader>cP ygv:<C-u>call NERDComment('x', 'comment')<CR>`<P
" }}}

" polyglot {{{
 let g:polyglot_disabled = ['tex', 'latex', 'python']
" }}}

" sneak {{{
let g:sneak#streak = 1
"replace 'f' with 1-char Sneak
nmap f <Plug>Sneak_f
xmap f <Plug>Sneak_f
omap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap F <Plug>Sneak_F
omap F <Plug>Sneak_F
"replace 't' with 1-char Sneak
nmap t <Plug>Sneak_t
xmap t <Plug>Sneak_t
omap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap T <Plug>Sneak_T
omap T <Plug>Sneak_T
" }}}

" tagbar {{{
nnoremap <leader>T :TagbarToggle<CR>
" }}}

" Ultisnips {{{
let g:UltiSnipsUsePythonVersion = 3
let g:UltiSnipsExpandTrigger = '<C-k>'
let g:UltiSnipsJumpForwardTrigger = '<C-k>'
let g:UltiSnipsJumpBackwardTrigger = '<C-j>'
let g:ultisnips_python_style = 'numpy'
let g:AutoPairsMapCR=0
inoremap <silent> <Plug>(MyCR) <CR><C-R>=AutoPairsReturn()<CR>
inoremap <silent> <expr> <CR> ncm2_ultisnips#expand_or("\<Plug>(MyCR)", 'im')
" }}}

" }}}

" Some final stuff {{{
syntax on
" }}}
